"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[312],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>h});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),s=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},u=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=s(r),p=a,h=m["".concat(c,".").concat(p)]||m[p]||d[p]||o;return r?n.createElement(h,l(l({ref:t},u),{},{components:r})):n.createElement(h,l({ref:t},u))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,l=new Array(o);l[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[m]="string"==typeof e?e:a,l[1]=i;for(var s=2;s<o;s++)l[s]=r[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},89742:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var n=r(87462),a=(r(67294),r(3905));const o={sidebar_position:2},l="Controllers",i={unversionedId:"communication/controllers",id:"communication/controllers",title:"Controllers",description:"Controllers have a similar API and functionality to services. The only difference is that controllers and services are separate; controllers are the client's version of services. This means that they are also tables, and similarly to WeaverServices, are also able to be created in modules.",source:"@site/docs/communication/controllers.md",sourceDirName:"communication",slug:"/communication/controllers",permalink:"/Weaver/docs/communication/controllers",draft:!1,editUrl:"https://github.com/paracosm-daemon/weaver/edit/main/docs/communication/controllers.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"Services",permalink:"/Weaver/docs/communication/services"},next:{title:"Execution Model",permalink:"/Weaver/docs/extras/execution-model"}},c={},s=[{value:"Construction",id:"construction",level:2},{value:"Sharing",id:"sharing",level:2},{value:"Communication",id:"communication",level:2}],u={toc:s},m="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"controllers"},"Controllers"),(0,a.kt)("p",null,"Controllers have a similar API and functionality to services. The only difference is that controllers and services are separate; controllers are the client's version of services. This means that they are also tables, and similarly to ",(0,a.kt)("a",{parentName:"p",href:"/api/WeaverServer#WeaverService"},"WeaverServices"),", are also able to be created in modules."),(0,a.kt)("h2",{id:"construction"},"Construction"),(0,a.kt)("p",null,"When creating a controller, the only key needed, much like a ",(0,a.kt)("a",{parentName:"p",href:"/api/WeaverServer#WeaverService"},"WeaverService"),", is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," property."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Controller = Weaver.CreateController{ Name = "Controller" }\n')),(0,a.kt)("p",null,"One difference between controllers and services is that controllers do not have a construction phase, where they are created and turned into a folder internally. This means that there is no ",(0,a.kt)("inlineCode",{parentName:"p"},"Attributes")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Client"),"-adjacent tables, rather the controller itself will store all that it needs. This means that communication between two controllers is simple; all you need to do is call ",(0,a.kt)("a",{parentName:"p",href:"/api/WeaverClient#GetController"},(0,a.kt)("inlineCode",{parentName:"a"},"WeaverClient.GetController()"))," within WeaverInit or WeaverStart."),(0,a.kt)("h2",{id:"sharing"},"Sharing"),(0,a.kt)("p",null,"Let's say that we have two controllers, one for controlling the camera, and one for controlling the character. Let's say that our camera controller needs a camera subject to function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local CameraController = Weaver.CreateController{ Name = "CameraController" }\nCameraController.cameraSubject = nil :: PVInstance?\n-- Here\'s our function for updating the camera\nfunction CameraController:UpdateCamera(): ()\n    local currentCamera: Camera = workspace.CurrentCamera\n    currentCamera.CameraType = Enum.CameraType.Scriptable\n    -- This will use our cameraSubject property to calculate the camera\'s position\n    local cameraSubject: PVInstance? = self.cameraSubject\n    if cameraSubject ~= nil then\n        currentCamera.CFrame = cameraSubject:GetPivot()\n    end\nend\nfunction CameraController:WeaverStart(): ()\n    -- Connect our UpdateCamera function to RenderStepped\n    RunService:BindToRenderStep("UpdateCamera", Enum.RenderPriority.Camera.Value, function(): ()\n        self:UpdateCamera()\n    end)\n    self:UpdateCamera()\nend\n')),(0,a.kt)("p",null,"Our character controller can supply that. So, our setup should look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local client = Weaver.Player -- Weaver exposes the LocalPlayer as this Player property\nlocal CharacterController = Weaver.CreateController{ Name = "CharacterController" }\n\nfunction CharacterController:HandleCharacter(character: Model): ()\n    -- Here, we set our cameraSubject to the character.\n    -- In return, our camera now tracks our character\'s location!\n    self.CameraController.cameraSubject = character\nend\nfunction CharacterController:WeaverStart(): ()\n    -- Just so it\'s easier to access from our other functions,\n    -- store CameraController in our controller.\n    -- See below for a different way of using GetController\n    self.CameraController = Weaver.GetController("CameraController")\n    client.CharacterAdded:Connect(function(character: Model): ()\n        self:HandleCharacter(character)\n    end)\n\n    local currentCharacter: Model? = client.Character\n    if currentCharacter then\n        self:HandleCharacter(currentCharacter)\n    end\nend\n')),(0,a.kt)("p",null,"If you would prefer to get your controllers in a different way, you can simply create the variables related to the controllers you want to get at the beginning of your module, then initialize them on WeaverInit. See below if you would like to use the alternative method."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Different GetController method"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Controller = Weaver.CreateController{ Name = "Controller" }\nlocal OtherController -- Leave this uninitialized for now!\n\nfunction Controller:WeaverInit(): ()\n    OtherController = Weaver.GetController("OtherController")\nend\nfunction Controller:WeaverStart(): ()\n    OtherController:DoSomething() -- This will work, since our controller was initialized in WeaverInit\nend\n')),(0,a.kt)("p",null,"This same logic can also be done for services.")),(0,a.kt)("p",null,"With our character and camera setup, we've designed our controllers to handle their own purposes while being able to share values from one to the other. This same principle can be applied to all sorts of controllers, as this same logic can be used to share a number value between controllers, check if a controller is on a debounce, or they can be used as signals. Since Weaver isn't too restrictive, you are able to make controllers do almost anything."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Signal = Weaver.Util.Signal\nlocal MagicController = Weaver.CreateController{ Name = "MagicController" }\n\nMagicController.MagicDone = Signal.new()\nMagicController.isPreparingTrick = false\n\nfunction MagicController:PerformMagic(): ()\n    if self.isPreparingTrick then\n        warn("Wait for the magician to set up the magic trick!")\n        return\n    end\n    print("\ud83c\udfa9\ud83e\ude84\ud83d\udc07")\n\n    self.MagicDone:Fire()\n    self.isPreparingTrick = true\n    -- After the magic trick is done, prepare for the next trick (this is a debounce)\n    task.wait(15)\n    self.isPreparingTrick = false\n\n    print("The show is ready to start again!")\nend\n')),(0,a.kt)("h2",{id:"communication"},"Communication"),(0,a.kt)("p",null,"With some controllers, you may have to communicate with the server. Weaver makes this easy with ",(0,a.kt)("a",{parentName:"p",href:"/api/WeaverClient#GetService"},(0,a.kt)("inlineCode",{parentName:"a"},"WeaverClient.GetService()")),", which loads a service, meaning its methods, signals, properties, and attributes will all be available once you load the service. Let's say that we would like to communicate to a points service to increment the client's points. First, we need our points service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"-- This is being ran on the server\nlocal PointsService = Weaver.CreateService{ Name = \"PointsService\" }\n\nPointsService.Client.Points = 0 -- This is a RemoteProperty! Our starting points will be 0\nPointsService.Client.AddPoints = Weaver.CreateRemoteSignal() -- Our signal to add more points\n\nfunction PointsService:WeaverInit(): ()\n    -- We'll be storing this as a variable\n    -- so that we don't need to write self.Client.Points\n    -- every time we want to access it\n    local Points: RemoteProperty = self.Client.Points\n    self.Client.AddPoints:Connect(function(Client: Player)\n        -- This will add 10 points every time the client fires AddPoints\n        Points:SetFor(Client, 10 + Points:GetFor(Client))\n    end)\nend\n")),(0,a.kt)("p",null,"In our controller, we want to fire AddPoints to update our points. Here's how we could hook a controller to PointsService:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- This is being ran on the client\nlocal PointsController = Weaver.CreateController{ Name = "PointsController" }\nlocal PointsService -- See the alternative method mentioned above\n\nfunction PointsController:WeaverInit(): ()\n    PointsService = Weaver.GetService("PointsService")\n    PointsService.Points.Changed:Connect(function(newPoints: number): ()\n        warn("Our points were changed to", newPoints)\n    end)\nend\nfunction PointsController:WeaverStart(): ()\n    print("Our starting points are", PointsService.Points:Get())\n    -- Fire our AddPoints signal to get some points\n    PointsService.AddPoints:Fire()\nend\n-- Output:\n-- Our starting points are 0\n-- Our points were changed to 10\n')),(0,a.kt)("p",null,"Generally, controllers do not need to access the networking of services, meaning your entire game could be solely reliant on controllers without the use of services. The only times you may need to access a service are to transceive data, such as settings or any client-specific game data that needs to be stored."))}d.isMDXComponent=!0}}]);