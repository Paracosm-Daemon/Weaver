[{"title":"SignalConnection","type":0,"sectionRef":"#","url":"/Weaver/api/SignalConnection","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"SignalConnection","url":"/Weaver/api/SignalConnection#properties","content":" "},{"title":"Connected​","type":1,"pageTitle":"SignalConnection","url":"/Weaver/api/SignalConnection#Connected","content":"&lt;/&gt; SignalConnection.Connected: boolean If the SignalConnection is connected to a Signal, this value will be true, otherwise false. "},{"title":"Functions​","type":1,"pageTitle":"SignalConnection","url":"/Weaver/api/SignalConnection#functions","content":" "},{"title":"Disconnect​","type":1,"pageTitle":"SignalConnection","url":"/Weaver/api/SignalConnection#Disconnect","content":"&lt;/&gt; SignalConnection:Disconnect() → () Disconnects the connection, removing it from the Signal it is connected to. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/Weaver/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#types","content":" "},{"title":"ConnectionCallback​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#ConnectionCallback","content":"&lt;/&gt; type ConnectionCallback = (...any) → ()  "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal object.  "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: ...any) → () Fires the signal with the specified data.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect( Callback: ConnectionCallback-- The function to connect. ) → SignalConnection Connects Callback to this signal, creating a new SignalConnection.  "},{"title":"ConnectParallel​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#ConnectParallel","content":"&lt;/&gt; Signal:ConnectParallel( Callback: ConnectionCallback-- The function to connect. ) → SignalConnection Connects Callback to this signal in parallel, creating a new SignalConnection. Useful for Parallel Luau.  "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#Once","content":"&lt;/&gt; Signal:Once( Callback: ConnectionCallback-- The function to connect. ) → SignalConnection Connects Callback to this signal, disconnecting it once the signal has fired once.  "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/Weaver/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any-- All of the data that the signal returned from one event. Waits for the event to fire before resuming the current thread. "},{"title":"WeaverClient","type":0,"sectionRef":"#","url":"/Weaver/api/WeaverClient","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#types","content":" "},{"title":"WeaverService​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#WeaverService","content":"&lt;/&gt; interface WeaverService { AttributeChanged: RBXScriptSignal GetAttributeChangedSignal: ( self: WeaverService, Attribute: string ) → RBXScriptSignal GetAttribute: ( self: WeaverService, Attribute: string ) → any [string]: RemoteSignal | RemoteProperty | ( self: WeaverService, ...any ) → (...any) } The type used for all services on the client.  "},{"title":"WeaverController​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#WeaverController","content":"&lt;/&gt; interface WeaverController { Name: string-- The name of the controller. [any]: any WeaverStart: (self: WeaverController) → ()? WeaverInit: (self: WeaverController) → ()? } The type used for all controllers. "},{"title":"Properties​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#properties","content":" "},{"title":"Player​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#Player","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; WeaverClient.Player: Player  A reference to Players.LocalPlayer that you can easily access through Weaver.  "},{"title":"Util​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; WeaverClient.Util: {Signal} A module that contains all of the utility modules that Weaver exposes. "},{"title":"Functions​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#functions","content":" "},{"title":"Start​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#Start","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; WeaverClient.Start() → () Starts Weaver. caution This will throw an error if Weaver is already started.  "},{"title":"OnStart​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#OnStart","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; WeaverClient.OnStart() → () Yields until Weaver has started. Useful for external modules that are not ran as controllers. If Weaver has already started, this will not yield.  "},{"title":"GetService​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#GetService","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; WeaverClient.GetService(Name: string) → WeaverService Returns the WeaverService found from the server. This will yield until a service matching the name is found.  "},{"title":"GetController​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#GetController","content":"&lt;/&gt; WeaverClient.GetController(Name: string) → WeaverController If the Name is used for a controller, returns the WeaverController from the server. caution This will throw an error if Weaver has not started, or if Name is not used for a controller.  "},{"title":"CreateController​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#CreateController","content":"&lt;/&gt; WeaverClient.CreateController(Controller: WeaverController) → WeaverController Creates and adds a WeaverController before Weaver has started. caution This will throw an error if Weaver has started.  "},{"title":"AddControllers​","type":1,"pageTitle":"WeaverClient","url":"/Weaver/api/WeaverClient#AddControllers","content":"&lt;/&gt; WeaverClient.AddControllers(Handle: Instance ) → {WeaverController} Adds all services from Handle to Weaver automatically. Returns an array of all of the added WeaverControllers. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/Weaver/api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#types","content":" "},{"title":"RemoteConnectionCallback​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#RemoteConnectionCallback","content":"&lt;/&gt; type RemoteConnectionCallback = (...any) → () | ( Client: Player , ...any )  "},{"title":"Properties​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#properties","content":" "},{"title":"Unreliable​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#Unreliable","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteSignal.Unreliable: boolean Determines whether the RemoteSignal is unreliable or not. "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#functions","content":" "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#Fire","content":"This item only works when running on the server. Server &lt;/&gt; RemoteSignal:Fire( Client: Player , ...: ...any-- The arguments to send over this RemoteSignal. ) → () Fires to the specified client, from the server. caution The first argument of Fire must be a Player.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#FireAll","content":"This item only works when running on the server. Server &lt;/&gt; RemoteSignal:FireAll(...: ...any) → () Fires to all clients in the game.  "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#FireFor","content":"This item only works when running on the server. Server &lt;/&gt; RemoteSignal:FireFor( For: {Player }, ...: ...any ) → () Fires to all clients specified in For.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#FireExcept","content":"This item only works when running on the server. Server &lt;/&gt; RemoteSignal:FireExcept( Excluding: {Player }, ...: ...any ) → () Fires to all clients in the game, except for the clients specified.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#FireFilter","content":"This item only works when running on the server. Server &lt;/&gt; RemoteSignal:FireFilter( Filter: ( Client: Player , ...any ) → boolean, ...: ...any ) → () Fires to all clients in the game, using a filter to specify which clients receive the event.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#Fire","content":"This item only works when running on the client. Client &lt;/&gt; RemoteSignal:Fire( ...: ...any-- The arguments to send over this RemoteSignal. ) → () Fires to the server, from the client.  "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( Callback: RemoteConnectionCallback-- The function to connect. ) → RBXScriptConnection  Connects Callback to this signal. Executes when a client fires this signal to the server, or vice versa.  "},{"title":"ConnectParallel​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#ConnectParallel","content":"&lt;/&gt; RemoteSignal:ConnectParallel( Callback: RemoteConnectionCallback-- The function to connect. ) → RBXScriptConnection  Connects Callback to this signal in parallel. Useful with Parallel Luau. Executes when a client fires this signal to the server, or vice versa.  "},{"title":"Once​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#Once","content":"&lt;/&gt; RemoteSignal:Once( Callback: RemoteConnectionCallback-- The function to connect. ) → RBXScriptConnection  Connects Callback to this signal, disconnecting it once the signal has fired once.  "},{"title":"Wait​","type":1,"pageTitle":"RemoteSignal","url":"/Weaver/api/RemoteSignal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RemoteSignal:Wait() → ...any-- All of the data that the signal returned from one event. Waits for the event to fire before resuming the current thread. "},{"title":"WeaverServer","type":0,"sectionRef":"#","url":"/Weaver/api/WeaverServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#types","content":" "},{"title":"WeaverMethod​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#WeaverMethod","content":"&lt;/&gt; type WeaverMethod = ( self: WeaverExposed, Invoker: Player , ...any ) → (...any)   "},{"title":"WeaverExposed​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#WeaverExposed","content":"&lt;/&gt; interface WeaverExposed { Server: WeaverService [string]: RemoteSignal | RemoteProperty | WeaverMethod } The type that the Client table in WeaverService uses.  "},{"title":"WeaverService​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#WeaverService","content":"&lt;/&gt; interface WeaverService { Name: string-- The name of the service. Client: WeaverExposed [any]: any WeaverStart: (self: WeaverService) → ()? WeaverInit: (self: WeaverService) → ()? AttributeChanged: RBXScriptSignal GetAttributeChangedSignal: ( self: WeaverService, Attribute: string ) → RBXScriptSignal GetAttribute: ( self: WeaverService, Attribute: string ) → any SetAttribute: ( self: WeaverService, Attribute: string, Value: any ) → () } The type used for all services on the server. "},{"title":"Properties​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#properties","content":" "},{"title":"Util​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; WeaverServer.Util: {Signal} A module that contains all of the utility modules that Weaver exposes. "},{"title":"Functions​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#functions","content":" "},{"title":"Start​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#Start","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; WeaverServer.Start() → () Starts Weaver. caution This will throw an error if Weaver has already started.  "},{"title":"OnStart​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#OnStart","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; WeaverServer.OnStart() → () Yields until Weaver has started. Useful for external modules that are not ran as services. If Weaver has already started, this will not yield.  "},{"title":"GetService​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#GetService","content":"&lt;/&gt; WeaverServer.GetService(Name: string) → WeaverService If the Name is used for a service, returns the WeaverService from the server. caution This will throw an error if Weaver has not started, or if Name is not used for a service.  "},{"title":"CreateService​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#CreateService","content":"&lt;/&gt; WeaverServer.CreateService(Service: { Attributes: {[string]: any}?, Client: {[string]: any}?, Name: string, [any]: any, WeaverStart: (self: WeaverService) → ()?, WeaverInit: (self: WeaverService) → ()? }) → WeaverMockService Creates and adds a WeaverService before Weaver has started. caution This will throw an error if Weaver has started.  "},{"title":"AddServices​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#AddServices","content":"&lt;/&gt; WeaverServer.AddServices(Handle: Instance ) → {WeaverService} Adds all services from Handle to Weaver automatically. Returns an array of all of the added WeaverServices.  "},{"title":"CreateRemoteSignal​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#CreateRemoteSignal","content":"&lt;/&gt; WeaverServer.CreateRemoteSignal() → Marker Creates a remote signal marker which is turned into a RemoteSignal when Weaver is started. caution This will only create a RemoteSignal if it is indexxed into the Client table.  "},{"title":"CreateUnreliableSignal​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#CreateUnreliableSignal","content":"&lt;/&gt; WeaverServer.CreateUnreliableSignal() → Marker Creates an unreliable signal marker which is turned into a RemoteSignal when Weaver is started. This is adjacent to Roblox's UnreliableRemoteEvent caution This will only create a RemoteSignal if it is indexxed into the Client table.  "},{"title":"CreateEmptyProperty​","type":1,"pageTitle":"WeaverServer","url":"/Weaver/api/WeaverServer#CreateEmptyProperty","content":"&lt;/&gt; WeaverServer.CreateEmptyProperty() → Marker Creates a RemoteProperty with a value of nil when Weaver has started. If you would like to create a RemoteProperty with a value, set your property in your Client table to any value, i.e Service.Client.Property = 0 caution This will only create a RemoteProperty if it is indexxed into the Client table. "},{"title":"Controllers","type":0,"sectionRef":"#","url":"/Weaver/docs/communication/controllers","content":"","keywords":""},{"title":"Construction​","type":1,"pageTitle":"Controllers","url":"/Weaver/docs/communication/controllers#construction","content":"When creating a controller, the only key needed, much like a WeaverService, is the Name property. local Controller = Weaver.CreateController{ Name = &quot;Controller&quot; }  One difference between controllers and services is that controllers do not have a construction phase, where they are created and turned into a folder internally. This means that there is no Attributes or Client-adjacent tables, rather the controller itself will store all that it needs. This means that communication between two controllers is simple; all you need to do is call WeaverClient.GetController() within WeaverInit or WeaverStart. "},{"title":"Sharing​","type":1,"pageTitle":"Controllers","url":"/Weaver/docs/communication/controllers#sharing","content":"Let's say that we have two controllers, one for controlling the camera, and one for controlling the character. Let's say that our camera controller needs a camera subject to function: local CameraController = Weaver.CreateController{ Name = &quot;CameraController&quot; } CameraController.cameraSubject = nil :: PVInstance? -- Here's our function for updating the camera function CameraController:UpdateCamera(): () local currentCamera: Camera = workspace.CurrentCamera currentCamera.CameraType = Enum.CameraType.Scriptable -- This will use our cameraSubject property to calculate the camera's position local cameraSubject: PVInstance? = self.cameraSubject if cameraSubject ~= nil then currentCamera.CFrame = cameraSubject:GetPivot() end end function CameraController:WeaverStart(): () -- Connect our UpdateCamera function to RenderStepped RunService:BindToRenderStep(&quot;UpdateCamera&quot;, Enum.RenderPriority.Camera.Value, function(): () self:UpdateCamera() end) self:UpdateCamera() end  Our character controller can supply that. So, our setup should look something like this: local client = Weaver.Player -- Weaver exposes the LocalPlayer as this Player property local CharacterController = Weaver.CreateController{ Name = &quot;CharacterController&quot; } function CharacterController:HandleCharacter(character: Model): () -- Here, we set our cameraSubject to the character. -- In return, our camera now tracks our character's location! self.CameraController.cameraSubject = character end function CharacterController:WeaverStart(): () -- Just so it's easier to access from our other functions, -- store CameraController in our controller. -- See below for a different way of using GetController self.CameraController = Weaver.GetController(&quot;CameraController&quot;) client.CharacterAdded:Connect(function(character: Model): () self:HandleCharacter(character) end) local currentCharacter: Model? = client.Character if currentCharacter then self:HandleCharacter(currentCharacter) end end  If you would prefer to get your controllers in a different way, you can simply create the variables related to the controllers you want to get at the beginning of your module, then initialize them on WeaverInit. See below if you would like to use the alternative method. Different GetController method local Controller = Weaver.CreateController{ Name = &quot;Controller&quot; } local OtherController -- Leave this uninitialized for now! function Controller:WeaverInit(): () OtherController = Weaver.GetController(&quot;OtherController&quot;) end function Controller:WeaverStart(): () OtherController:DoSomething() -- This will work, since our controller was initialized in WeaverInit end This same logic can also be done for services. With our character and camera setup, we've designed our controllers to handle their own purposes while being able to share values from one to the other. This same principle can be applied to all sorts of controllers, as this same logic can be used to share a number value between controllers, check if a controller is on a debounce, or they can be used as signals. Since Weaver isn't too restrictive, you are able to make controllers do almost anything. local Signal = Weaver.Util.Signal local MagicController = Weaver.CreateController{ Name = &quot;MagicController&quot; } MagicController.MagicDone = Signal.new() MagicController.isPreparingTrick = false function MagicController:PerformMagic(): () if self.isPreparingTrick then warn(&quot;Wait for the magician to set up the magic trick!&quot;) return end print(&quot;🎩🪄🐇&quot;) self.MagicDone:Fire() self.isPreparingTrick = true -- After the magic trick is done, prepare for the next trick (this is a debounce) task.wait(15) self.isPreparingTrick = false print(&quot;The show is ready to start again!&quot;) end  "},{"title":"Communication​","type":1,"pageTitle":"Controllers","url":"/Weaver/docs/communication/controllers#communication","content":"With some controllers, you may have to communicate with the server. Weaver makes this easy with WeaverClient.GetService(), which loads a service, meaning its methods, signals, properties, and attributes will all be available once you load the service. Let's say that we would like to communicate to a points service to increment the client's points. First, we need our points service: -- This is being ran on the server local PointsService = Weaver.CreateService{ Name = &quot;PointsService&quot; } PointsService.Client.Points = 0 -- This is a RemoteProperty! Our starting points will be 0 PointsService.Client.AddPoints = Weaver.CreateRemoteSignal() -- Our signal to add more points function PointsService:WeaverInit(): () -- We'll be storing this as a variable -- so that we don't need to write self.Client.Points -- every time we want to access it local Points: RemoteProperty = self.Client.Points self.Client.AddPoints:Connect(function(Client: Player) -- This will add 10 points every time the client fires AddPoints Points:SetFor(Client, 10 + Points:GetFor(Client)) end) end  In our controller, we want to fire AddPoints to update our points. Here's how we could hook a controller to PointsService: -- This is being ran on the client local PointsController = Weaver.CreateController{ Name = &quot;PointsController&quot; } local PointsService -- See the alternative method mentioned above function PointsController:WeaverInit(): () PointsService = Weaver.GetService(&quot;PointsService&quot;) PointsService.Points.Changed:Connect(function(newPoints: number): () warn(&quot;Our points were changed to&quot;, newPoints) end) end function PointsController:WeaverStart(): () print(&quot;Our starting points are&quot;, PointsService.Points:Get()) -- Fire our AddPoints signal to get some points PointsService.AddPoints:Fire() end -- Output: -- Our starting points are 0 -- Our points were changed to 10  Generally, controllers do not need to access the networking of services, meaning your entire game could be solely reliant on controllers without the use of services. The only times you may need to access a service are to transceive data, such as settings or any client-specific game data that needs to be stored. "},{"title":"Execution Model","type":0,"sectionRef":"#","url":"/Weaver/docs/extras/execution-model","content":"","keywords":""},{"title":"Lifecycle​","type":1,"pageTitle":"Execution Model","url":"/Weaver/docs/extras/execution-model#lifecycle","content":"Weaver's execution model is simple yet orderly, ensuring all controllers and services will be ready as soon as their respective hosts start Weaver. Weaver is requiredWeaverServices and WeaverControllers are createdWeaverServer.Start() and WeaverClient.Start() respectively are called Weaver internally constructs the services when WeaverServer.Start() is called Every WeaverInit method is invoked Weaver waits for all respective WeaverService:WeaverInit() and WeaverController:WeaverInit() methods to resolve before continuing to the next step Every WeaverStart method is invoked, spawning new threads for all services and controllersAll threads yielding from WeaverServer.OnStart() and WeaverClient.OnStart() respectfully are resumed  "},{"title":"Explanation​","type":1,"pageTitle":"Execution Model","url":"/Weaver/docs/extras/execution-model#explanation","content":"When WeaverServer.Start() is called, all of the WeaverServices are instantiated internally, which includes RemoteSignals and methods. This step does not happen on the client, rather, services are dynamically created when WeaverClient.GetService() is called. Internally, all services' signals and their attributes are guaranteed to be ready when they are returned using WeaverClient.GetService(). This is because they are created before WeaverInit, as other services may use or rely on a service's RemoteSignals during WeaverInit or WeaverStart. This is the same for how WeaverControllers behave, just without creating instances. caution WeaverServices and WeaverControllers are unable to be created once their respective hosts have started Weaver. "},{"title":"Best Practice​","type":1,"pageTitle":"Execution Model","url":"/Weaver/docs/extras/execution-model#best-practice","content":"When using Weaver, your project structure should generally follow these rules: One script on the server manages the WeaverServer This means that all service modules should be used in one script, alongside WeaverServer.Start() One script on the client manages the WeaverClient This means that all controller modules should be used in one script, alongside WeaverClient.Start() Since Weaver relies on a single-script architecture, it may not work correctly if your project has a multi-script architecture. "},{"title":"Installation","type":0,"sectionRef":"#","url":"/Weaver/docs/getting-started/installation","content":"","keywords":""},{"title":"Method 1 - Wally​","type":1,"pageTitle":"Installation","url":"/Weaver/docs/getting-started/installation#method-1---wally","content":"Since Weaver is available as a package for Wally, you are able to install it by adding this beneath [dependencies] in your wally.toml file: Weaver = &quot;paracosm-daemon/weaver@^1.0.0&quot; If you would like to use Wally, you can learn more here. Recommended This is the recommended method to install Weaver. "},{"title":"Method 2 - Roblox Creator Store​","type":1,"pageTitle":"Installation","url":"/Weaver/docs/getting-started/installation#method-2---roblox-creator-store","content":"Weaver is also available as a module on the Roblox Creator Store. Installing it is relatively simple. First, get the model. To add it to your inventory, you simply click the &quot;Get Model&quot; button.  Once you've acquired the model, you're free to add it into Studio. You should see it within your inventory:  Finally, insert the model into your game, and then slot it somewhere you can easily access. Usually, it may go in a folder like ReplicatedStorage/Shared/Weaver, but it's up to you.  "},{"title":"Method 3 - From GitHub​","type":1,"pageTitle":"Installation","url":"/Weaver/docs/getting-started/installation#method-3---from-github","content":"Weaver can also be installed via cloning the GitHub repository. First, navigate to the GitHub page, then locate the &quot;Code&quot; button. Once you open the dropdown, click &quot;Download ZIP&quot; to download the repository onto your computer.  Once it's downloaded, extract the ZIP file, and drop Weaver into your project. Once it's in, it should look like this:  You are also fine to clear out most of the files if you worry about storage space; the only files you need are within src/, alongside default.project.json. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/Weaver/api/RemoteProperty","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#types","content":" "},{"title":"RemoteConnectionCallback​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#RemoteConnectionCallback","content":"&lt;/&gt; type RemoteConnectionCallback = (...any) → () | ( Client: Player , ...any )  "},{"title":"Properties​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#Changed","content":"This item only works when running on the client. Client &lt;/&gt; RemoteProperty.Changed: Signal Fires when the RemoteProperty's value has changed. Note that this won't fire if the value that the server sets is the same as your currently registered value. "},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#Set","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:Set(Default: any?) → () Sets the default value of the RemoteProperty, clearing all clients' custom values.  "},{"title":"SetDefault​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#SetDefault","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:SetDefault(Default: any?) → () Sets the default value of the RemoteProperty without clearing all clients' custom values.  "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#SetFor","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:SetFor( For: Player , Value: any? ) → () Sets the value of this RemoteProperty for a specific client.  "},{"title":"SetForEach​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#SetForEach","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:SetForEach( For: {Player }, Value: any? ) → () Sets the value of this RemoteProperty for the clients specified.  "},{"title":"SetExcept​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#SetExcept","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:SetExcept( Excluding: {Player }, Value: any? ) → () Sets the value of this RemoteProperty for all clients in the game, except for the clients specified.  "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#SetFilter","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:SetFilter( Filter: ( Client: Player , Value: any? ) → boolean, Value: any? ) → () Sets the value of this RemoteProparty for all clients in the game, using a filter to specify which clients have their values set.  "},{"title":"Clear​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#Clear","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:Clear() → () Clears all clients' custom values.  "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#ClearFor","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:ClearFor(For: Player ) → () Clears the value set for a specific client.  "},{"title":"ClearForEach​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#ClearForEach","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:ClearForEach(For: {Player }) → () Clears the values set for the clients specified.  "},{"title":"ClearExcept​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#ClearExcept","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:ClearExcept(Excluding: {Player }) → () Clears the value of all clients in the game, except for the clients specified.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#ClearFilter","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:ClearFilter(Filter: (Client: Player ) → boolean) → () Clears the value of all clients in the game, using a filter to specify which clients receive the event.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#Get","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:Get() → any? Gets the current value of the RemoteProperty.  "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#GetFor","content":"This item only works when running on the server. Server &lt;/&gt; RemoteProperty:GetFor(Client: Player ) → any? Gets the current value of the RemoteProperty for Client.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/Weaver/api/RemoteProperty#Get","content":"This item only works when running on the client. Client This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RemoteProperty:Get() → any? Gets the current value of the RemoteProperty. Yielding This function will yield when you first call :Get() if the server has not sent a Changed event at least once. If this is an issue that worries you, try calling :Get() once in WeaverController:WeaverInit() so that the value is guaranteed to exist. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/Weaver/docs/intro","content":"","keywords":""},{"title":"Why Weaver?​","type":1,"pageTitle":"Introduction","url":"/Weaver/docs/intro#why-weaver","content":""},{"title":"Reliability​","type":1,"pageTitle":"Introduction","url":"/Weaver/docs/intro#reliability","content":"Since Weaver's structure is built around a single-script architecture, your code is guaranteed to run in an order you can easily manage. WeaverServices and WeaverControllers will always be ready on WeaverInit, and fully initialized on WeaverStart. You can also read more about Weaver's execution model. "},{"title":"Infrastructure​","type":1,"pageTitle":"Introduction","url":"/Weaver/docs/intro#infrastructure","content":"Weaver allows for a simpler way of networking between the server and client. You don't need to add RemoteEvents or RemoteFunctions to your game's hierarchy at all; Weaver automatically bridges the gap between the server and the client with custom-made and typed implementations of these classes. "},{"title":"Accessibility​","type":1,"pageTitle":"Introduction","url":"/Weaver/docs/intro#accessibility","content":"Weaver is greatly accessible - from grabbing the module via Roblox's Creator Store to using it as a package in Wally, installation is straightforward and made to fit your workflow. And, once it is added to your project, using it is simple; all you need to do is require Weaver. You can read more about using Weaver here. "},{"title":"Adaptability​","type":1,"pageTitle":"Introduction","url":"/Weaver/docs/intro#adaptability","content":"Since Weaver is under the MIT license, you're always free to fork the source code, fix or add features by making a pull request, or even modify and distribute your own version of the framework. Weaver will always be open source and mendable to your liking; all contributions towards improving the framework are greatly appreciated. "},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"/Weaver/docs/getting-started/usage","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Basic Usage","url":"/Weaver/docs/getting-started/usage#methods","content":"First, we're going to set up the service, and then specify a method to respond to any client's request to ping the server. -- This is being ran on the server -- CreateService's parameter is a table, -- and Name has to be specified as a string for it to be registered local PingService = Weaver.CreateService{ Name = &quot;PingService&quot; } -- Since this method is going to be shared with the client, specify it under the Client table function PingService.Client:Ping(): string return &quot;Pong!&quot; end -- Finally, start Weaver after our service is created Weaver.Start()  Then, on the client, you can get PingService using WeaverClient.GetService(), and run PingService:Ping() to play ping-pong. -- This is being ran on the client local Weaver = require(Weaver) -- Since Weaver needs to be started to get services and controllers, -- it's done before we call Weaver.GetService() Weaver.Start() -- Get PingService; it's almost like calling game:GetService() local PingService = Weaver.GetService(&quot;PingService&quot;) -- Start our game of ping-pong on the client print(&quot;Ping!&quot;) local pingStart: number = os.clock() -- Call PingService:Ping(), which will return &quot;Pong!&quot; local pongOutput: string = PingService:Ping() -- Calculate how long it took for the server to respond to our request local pongTime: number = os.clock() - pingStart warn(pongOutput, &quot;took&quot;, pongTime) -- Pong! took 0.31758950000221375  Just like that, we've created a service to play ping-pong with. Under the hood, Weaver converts your function into a RemoteFunction, though it is handled as if it were a normal function on the client. If you find Weaver's i rnal structure while running your game, you can see how it's built:  "},{"title":"RemoteSignals​","type":1,"pageTitle":"Basic Usage","url":"/Weaver/docs/getting-started/usage#remotesignals","content":"Let's say that we want to use a RemoteEvent instead, and in this case, for posting a message via MessagingService. We can use WeaverServer.CreateRemoteSignal() to create a signal which will be listened to on the client. In practice, the server would look something like this: -- This is being ran on the server local MessagingService = game:GetService(&quot;MessagingService&quot;) -- This will be the topic we post to local POST_TOPIC: string = &quot;GlobalMessages&quot; type Payload = { name: string, message: string } -- First, create PostService local PostService = Weaver.CreateService{ Name = &quot;PostService&quot; } -- Then, create the remote signal. -- Trying to use it before Weaver has started will throw an exception PostService.Client.SendMessage = Weaver.CreateRemoteSignal() -- Connections are done within WeaverInit so that they are ready on WeaverStart function PostService:WeaverInit(): () -- First, subscribe to listen to payloads from SendMessage MessagingService:SubscribeAsync(POST_TOPIC, function(received: { Data: Payload, Sent: number }): () local payload: Payload = received.Data print(&quot;Player&quot;, payload.name, &quot;sent&quot;, payload.message) end) -- Then, connect SendMessage. -- This will take a string as its message parameter self.Client.SendMessage:Connect(function(client: Player, message: string): () -- Normally, you'd want to add sanity checks, -- but this is just an example local payload: Payload = { name = client.Name; message = message; } MessagingService:PublishAsync(POST_TOPIC, payload) end) end  Under the hood, this simply creates a RemoteEvent. This differs from methods as they do not yield when you call RemoteSignal:Fire(). Now, let's say that we want to call SendMessage from the client. All we need to do is call SendMessage:Fire(), as it gets registered as a RemoteSignal when Weaver starts. This is what the client may look like: -- This is being ran on the client local Weaver = require(Weaver) Weaver.Start() local PostService = Weaver.GetService(&quot;PostService&quot;) PostService.SendMessage:Fire(&quot;Hello from the client!&quot;) -- That's all!  More information on communication can be found on the Communications page. "},{"title":"Migration from Knit","type":0,"sectionRef":"#","url":"/Weaver/docs/extras/migrate","content":"","keywords":""},{"title":"Runners​","type":1,"pageTitle":"Migration from Knit","url":"/Weaver/docs/extras/migrate#runners","content":"local Knit = require(Knit) Knit.AddServices(script.Runtime) Knit.Start():andThen(function(): () print(&quot;Knit has started!&quot;) end):catch(warn)  This is a simple Knit service runner which relies on the use of Promises to handle errors and run code after Knit successfully starts. This behavior can be ported into Weaver in multiple ways. The easiest and most familiar way to port this is by using the Promise library by evaera. local Promise = require(Promise) local Weaver = require(Weaver) Weaver.AddServices(script.Runtime) Promise.try(Weaver.start):andThen(function(): () print(&quot;Weaver has started!&quot;) end):catch(warn)  If you use the Promise library already, this should be easy to implement in your own code. Otherwise, an easier way is to use xpcall: local Weaver = require(Weaver) Weaver.AddServices(script.Runtime) -- Since xpcall yields, any code will be ran after this -- Think of this as Promise:await() xpcall(function(): () Weaver.Start() print(&quot;Weaver has started!&quot;) end, warn)  You can also wrap the xpcall in a task.spawn thread to replicate the new thread that Promises spawn, rather than the yielding behavior: local Weaver = require(Weaver) Weaver.AddServices(script.Runtime) -- This is functionally the same as Promise.try task.spawn(xpcall, function(): () Weaver.Start() print(&quot;Weaver has started!&quot;) end, warn)  This way of error handling also goes for Weaver.OnStart(). "},{"title":"Networking​","type":1,"pageTitle":"Migration from Knit","url":"/Weaver/docs/extras/migrate#networking","content":"The equivalent to Knit.CreateSignal() in Weaver is WeaverServer.CreateRemoteSignal(). They are functionally the same, but named differently. In Studio, or if you use an IDE, using the shortcut CTRL + SHIFT + H should open a &quot;Search and Replace&quot; menu for all scripts in your project. You can easily replace all mentions of CreateSignal with CreateRemoteSignal this way. Ditto for replacing mentions of Knit with Weaver. The class that was majorly overhauled was RemoteProperty. While most of the API is the same, there is no RemoteProperty:Observe(), unlike Knit's version. It was instead replaced with the RemoteProperty.Changed signal, which does not fire when the value for the client has loaded. There is also no substitute to Knit.CreateProperty(), rather, any values you set in your Client table aside from the remote signal markers will be converted into RemoteProperties. Here's an example of how you would make a RemoteProperty in Knit: local Service = Knit.CreateService{ Name = &quot;Service&quot; } Service.Client.RemoteProperty = Knit.CreateProperty(0)  In Weaver, the constructor has been changed to this: local Service = Weaver.CreateService{ Name = &quot;Service&quot; } Service.Client.RemoteProperty = 0  Due to this, you are not able to initialize properties with a value of nil in Weaver. This has instead been substituted with the WeaverService.CreateEmptyProperty() function: local Service = Weaver.CreateService{ Name = &quot;Service&quot; } Service.Client.RemoteProperty = Weaver.CreateEmptyProperty()  Generally, the API for RemoteProperties is not too different outside of the RemoteProperty.Changed signal. Do note that RemoteProperty:SetTop(), RemoteProperty:SetForList(), and RemoteProperty:ClearForList() have been renamed to RemoteProperty:SetDefault(), RemoteProperty:SetForEach(), and RemoteProperty:ClearForEach() respectively. Extra quality-of-life methods have also been added, which you can see in Weaver's RemoteProperty API reference. "},{"title":"Services","type":0,"sectionRef":"#","url":"/Weaver/docs/communication/services","content":"","keywords":""},{"title":"Construction​","type":1,"pageTitle":"Services","url":"/Weaver/docs/communication/services#construction","content":"When creating a service, the only key needed in the table is the Name property, like so: local Service = Weaver.CreateService({ Name = &quot;Service&quot; })  If the extra parenthesis do not fit your coding style, you can also remove them: local Service = Weaver.CreateService{ Name = &quot;Service&quot; }  Other values are also able to be specified in this initialization phase, such as the Client table. This table is what exposes certain methods or signals to the client. It's also possible to specify an Attributes table, which are directly tied to Roblox's instance attributes. local Service = Weaver.CreateService{ Name = &quot;Service&quot;; Attributes = { isService = true; }; Client = { Shoot = Weaver.CreateRemoteSignal(); }; }  Alongside this, you're also free to add any other items to the service's table itself; the only restrictive table are the Client and Attributes tables. The Client table accepts methods and RemoteSignal markers, which are created via WeaverServer.CreateRemoteSignal() and WeaverServer.CreateUnreliableSignal(). Any other type is classified as a RemoteProperty, and will be instantiated as one. local Service = Weaver.CreateService{ Name = &quot;Service&quot;; Client = { ImportantCall = Weaver.CreateRemoteSignal(); SomeProperty = 0; GetSomething = function(self: WeaverExposed): string return &quot;Something&quot; end; }; someSharedValue = 123; someOtherSharedValue = &quot;hello&quot;; someSharedValues = { 1, 2, 3 }; }  caution The Client table is shallow, and all other tables inside of it will be converted into a RemoteProperty once Weaver starts. "},{"title":"Signals​","type":1,"pageTitle":"Services","url":"/Weaver/docs/communication/services#signals","content":"Let's say that we don't want to expose signals to the client, rather, we want to have an event that other services can listen to, like a BindableEvent. Weaver implements this through it's built-in class: Signal. You are able to create a Signal by using the module located at Weaver.Util.Signal. Unlike RemoteSignals, these are available as soon as you create them via Signal.new(). First, we create our service, which handles our signal: local Signal = Weaver.Util.Signal -- Util is a module, and Signal is already required! local EventFiringService = Weaver.CreateService{ Name = &quot;EventFiringService&quot;; SomethingHappened = Signal.new(); } function EventFiringService:WeaverStart(): () -- Fire SomethingHappened in WeaverStart, -- as the connections from other services should be ready self.SomethingHappened:Fire() end  Then, we create our service which uses this signal: local EventHandlingService = Weaver.CreateService{ Name = &quot;EventHandlingService&quot; } function EventHandlingService:WeaverInit(): () -- First, we get the service local EventFiringService = Weaver.GetService(&quot;EventFiringService&quot;) -- Then, we connect an event to it EventFiringService.SomethingHappened:Connect(function(): () print(&quot;Something happened!&quot;) end) end  caution Trying to add Signals to WeaverService.Client will not work. The signal will still exist, but it will not be accessible from Client once Weaver starts, as it cannot be exposed to the client. "},{"title":"Properties​","type":1,"pageTitle":"Services","url":"/Weaver/docs/communication/services#properties","content":"Weaver also has support for RemoteProperties. These are properties which are set by the server, and passed to the client. These properties are also able to be different for every client, while still having a default value. This is great for services which may handle points or currency. As an example, here is a basic money service: local MoneyService = Weaver.CreateService{ Name = &quot;MoneyService&quot; } -- This will initialize as a RemoteProperty once Weaver is initialized -- The value this is set to will be used as the default MoneyService.Client.Money = 0 MoneyService.Client.AddMoney = Weaver.CreateRemoteSignal() local Money -- This gets initialized in WeaverInit, so it can be used as a shorthand -- This is in the server table, so this won't clash with the signal's name function MoneyService:AddMoney(Client: Player, Amount: number): () Money:SetFor(Client, Money:GetFor(Client) + Amount) end function MoneyService:WeaverInit(): () -- Initialize our Money variable Money = self.Client.Money -- Hook our AddMoney signal to the AddMoney function aswell, -- so players can also give themselves money self.Client.AddMoney:Connect(function(Client: number, Amount: number): () self:AddMoney(Client, Amount) end) end  This service has a setup where both services and clients can add money to their own values, though you may not want to have a setup like this in production. Similar logic can be used for something that relies on data; if your game uses DataStores, you may want to set a client's value on a RemoteProperty to their stored value once they load in. This value could be something like the number of kills a client has reached, or their current level and experience points. Do note that RemoteProperties can have all data types that RemoteEvents support. The methods, signals, properties, and attributes all have their own distinct uses. You should pick which one you want to use based on which is the mose optimal for your own use cases. "},{"title":"Initialization​","type":1,"pageTitle":"Services","url":"/Weaver/docs/communication/services#initialization","content":"Trying to utilize services before Weaver has started will result in errors, especially when dealing with RemoteSignals. This is because Weaver needs to construct all of the services internally so that they are ready when WeaverInit and WeaverStart are called. This is because the client could have unexpected behavior dealing with services, as issues related to race conditions may cause certain signals to be missing, should services be initialized early. Weaver's way of dealing with this is through two methods: WeaverInit and WeaverStart. As outlined in the execution model, all service objects are internally created and handled, then WeaverInit is called, followed by WeaverStart. These methods are declared by adding Service:WeaverInit() and Service:WeaverStart() to your service. local MyMultiStepService = Weaver.CreateService{ Name = &quot;Service&quot;; Client = { SomeExposedSignal = Weaver.CreateRemoteSignal(); }; } function MyMultiStepService:WeaverInit(): () print(&quot;Init&quot;, self.Name) -- Connect some events here... self.Client.SomeExposedSignal:Connect(function(client: Player): () warn(client, &quot;fired my exposed signal!&quot;) end) end function MyMultiStepService:WeaverStart(): () print(&quot;Start&quot;, self.Name) -- Fire some events or execute some functions here... local SomeOtherService = Weaver.GetService(&quot;SomeOtherService&quot;) SomeOtherService.SomeSignal:Fire(123) end -- Output: -- Init Service -- Start Service  As seen above, WeaverInit will always be called before WeaverStart. This goes for all services that you create for your WeaverServer. The best practice is to connect handlers for Signals, RemoteSignals, or other RBXScriptSignals in WeaverInit, and then execute functions or handle things that update based on the task scheduler — i.e RunService.PostSimulation — in WeaverStart. This helps to prevent race conditions from occuring, where you may fire a signal before its handler is connected. Note that anything outside of the Client table is not exposed to any clients. This is to guarantee safety as you can control what clients are able to access. Usually, for formatting purposes, you may also want to define Client outside of WeaverServer.CreateService(). local Service = Weaver.CreateService{ Name = &quot;Service&quot; } Service.Client.SomeSignal = Weaver.CreateRemoteSignal() function Service.Client:IncrementNumber(value: number): number return value + 1 end  If you have ModuleScripts for every WeaverService, you are also able to use WeaverServer.AddServices() to add all of your services in bulk. This makes it easy to load all of your services at once, and it's especially useful if all of your services are in one location. local Weaver = require(Weaver) Weaver.AddServices(script.Runtime) -- Just an example of a directory to store your services in Weaver.Start()  "},{"title":"Caveats​","type":1,"pageTitle":"Services","url":"/Weaver/docs/communication/services#caveats","content":"When you first create a Weaver service, a few things will not be available: WeaverService.Client will not be initialized until Weaver is started, meaning all RemoteSignals will still be markers, and all RemoteProperties will only be the values that you put in the Client table.Client.Server, which is used to access the Server table from methods within the Client table, will also not be initialized until Weaver has started.All of WeaverService's attribute methods will be unavailable, as Weaver needs to start to initialize the service, which then internally sets the attributes and exposes the methods. See Weaver's execution model to understand how services are initialized. "}]